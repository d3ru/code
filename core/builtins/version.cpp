// version.cpp
// 
// Copyright (c) 2008 - 2011 Accenture. All rights reserved.
// This component and the accompanying materials are made available
// under the terms of the "Eclipse Public License v1.0"
// which accompanies this distribution, and is available
// at the URL "http://www.eclipse.org/legal/epl-v10.html".
// 
// Initial Contributors:
// Accenture - Initial contribution
//

#include "version.h"

// Note, this function is generated by "group\genver.pl".
extern HBufC* GetVersionInfoL(TBool aVerbose);

CCommandBase* CCmdVersion::NewLC()
	{
	CCmdVersion* self = new(ELeave) CCmdVersion();
	CleanupStack::PushL(self);
	self->BaseConstructL();
	return self;
	}

CCmdVersion::~CCmdVersion()
	{
	delete iRequiredVersion;
	}

CCmdVersion::CCmdVersion()
	{
	}

const TDesC& CCmdVersion::Name() const
	{
	_LIT(KName, "version");	
	return KName;
	}

void CCmdVersion::DoRunL()
	{
	if ((iShort || iRequiredVersion) && iVerbose) iVerbose = EFalse; // Verbose doesn't make sense with these options
	HBufC* version = GetVersionInfoL(iVerbose);
	CleanupStack::PushL(version);

	if (iRequiredVersion || iShort)
		{
		TLex lex(*version);
		lex.SkipCharacters(); // The 'Release'
		lex.SkipSpace();
		TInt majorVer = 0;
		lex.Val(majorVer);
		TInt minorVer = 0;
		if (lex.Peek() == '.')
			{
			lex.Inc();
			lex.Val(minorVer);
			}

		if (iShort)
			{
			Printf(_L("%d"), majorVer * 1000 + minorVer);
			}
		else if (iRequiredVersion)
			{
			TLex lex(*iRequiredVersion);
			TInt requiredVersion;
			LeaveIfErr(lex.Val(requiredVersion), _L("Couldn't parse version string %S"), iRequiredVersion);
			requiredVersion *= 1000;
			if (lex.Peek() == '.')
				{
				lex.Inc();
				TInt minor;
				LeaveIfErr(lex.Val(minor), _L("Couldn't parse version string %S"), iRequiredVersion);
				requiredVersion += minor;
				}
			if (requiredVersion > (majorVer*1000)+minorVer)
				{
				LeaveIfErr(KErrNotSupported, _L("fshell version %S required"), iRequiredVersion);
				}
			}
		}
	else
		{
		Stdout().Write(*version);
		}
	CleanupStack::PopAndDestroy(version);
	}

void CCmdVersion::OptionsL(RCommandOptionList& aOptions)
	{
	_LIT(KOptVerbose, "verbose");
	aOptions.AppendBoolL(iVerbose, KOptVerbose);
	_LIT(KOptShort, "short");
	aOptions.AppendBoolL(iShort, KOptShort);
	}

void CCmdVersion::ArgumentsL(RCommandArgumentList& aArguments)
	{
	_LIT(KArgRequired, "required-version");
	aArguments.AppendStringL(iRequiredVersion, KArgRequired);
	}
